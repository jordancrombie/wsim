// WSIM - Wallet Simulator Database Schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// WALLET USER & PROFILE
// =============================================================================

model WalletUser {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String?  // Nullable - legacy users may not have passwords (passkey-only)
  firstName    String?
  lastName     String?
  walletId     String   @unique @default(uuid()) // Public wallet identifier
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relationships
  enrollments           BsimEnrollment[]
  walletCards           WalletCard[]
  paymentConsents       WalletPaymentConsent[]
  passkeyCredentials    PasskeyCredential[]
  mobileDevices         MobileDevice[]
  mobileRefreshTokens   MobileRefreshToken[]
  mobilePaymentRequests MobilePaymentRequest[]
}

// =============================================================================
// BSIM ENROLLMENT
// =============================================================================

model BsimEnrollment {
  id     String     @id @default(uuid())
  userId String
  user   WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // BSIM identification
  bsimId     String // e.g., "td-bank", "rbc-bank"
  bsimIssuer String // OIDC issuer URL
  fiUserRef  String // User's ID at this bsim (sub claim)

  // Wallet credential (wcred_xxx token from BSIM for card operations)
  walletCredential String // Encrypted credential

  // OAuth access token (JWT for Open Banking API calls like /accounts)
  accessToken String? // Encrypted JWT - nullable for backwards compatibility

  // Token expiry (applies to accessToken, wallet credential may have longer expiry)
  credentialExpiry DateTime?

  // Refresh token for token renewal
  refreshToken String? // Encrypted

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Cards from this enrollment
  cards WalletCard[]

  @@unique([userId, bsimId])
  @@index([userId])
}

// =============================================================================
// WALLET CARDS
// =============================================================================

model WalletCard {
  id           String         @id @default(uuid())
  userId       String
  user         WalletUser     @relation(fields: [userId], references: [id], onDelete: Cascade)
  enrollmentId String
  enrollment   BsimEnrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)

  // Card display info (masked - no full card numbers stored)
  cardType       String // VISA, MC, AMEX, VISA_DEBIT, MC_DEBIT
  lastFour       String // Last 4 digits
  cardholderName String
  expiryMonth    Int
  expiryYear     Int

  // Card reference at bsim (NOT the actual card number)
  bsimCardRef String // Reference ID at bsim

  // Wallet card token (wsim-issued, for nsim routing)
  // Format: wsim_{bsimId}_{uniqueId}
  walletCardToken String @unique

  // Status
  isDefault Boolean @default(false)
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([enrollmentId, bsimCardRef])
  @@index([userId])
  @@index([walletCardToken])
}

// =============================================================================
// PAYMENT CONSENTS (for SSIM payments)
// =============================================================================

model WalletPaymentConsent {
  id     String     @id @default(uuid())
  userId String
  user   WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Merchant info
  merchantId   String
  merchantName String

  // Selected card
  walletCardId String

  // Consent details
  scope     String // e.g., "payment:single" or "payment:recurring"
  maxAmount Decimal? @db.Decimal(15, 2)

  // Token issued to merchant (returned in OIDC token claims)
  consentToken String @unique

  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([consentToken])
}

// =============================================================================
// PAYMENT CONTEXT (temporary storage during OIDC flow)
// =============================================================================

model PaymentContext {
  id String @id @default(uuid())

  // Link to OIDC grant
  grantId String @unique

  // Selected card info
  walletCardId    String
  walletCardToken String // WSIM token for NSIM routing

  // Card token from BSIM (for payment processing)
  bsimCardToken String?

  // Payment details from SSIM
  merchantId   String?
  merchantName String?
  amount       Decimal? @db.Decimal(15, 2)
  currency     String?

  createdAt DateTime @default(now())
  expiresAt DateTime // Short-lived, 10 minutes

  @@index([grantId])
}

// =============================================================================
// OIDC PROVIDER STORAGE (for auth-server)
// =============================================================================

model OidcPayload {
  id         String    @id
  type       String // e.g., "Session", "AccessToken", "AuthorizationCode", etc.
  payload    String    @db.Text
  grantId    String?
  userCode   String?
  uid        String?
  expiresAt  DateTime?
  consumedAt DateTime?

  @@index([grantId])
  @@index([userCode])
  @@index([uid])
}

// =============================================================================
// OAUTH CLIENTS (SSIMs registered to use WSIM)
// =============================================================================

model OAuthClient {
  id                     String   @id @default(uuid())
  clientId               String   @unique
  clientSecret           String // Hashed
  clientName             String
  redirectUris           String[]
  postLogoutRedirectUris String[]
  grantTypes             String[] // e.g., ["authorization_code", "refresh_token"]
  scope                  String // Space-separated scopes
  logoUri                String?
  trusted                Boolean  @default(false) // Skip consent for trusted clients

  // Merchant API key for direct API access (Phase 3)
  apiKey String? @unique // Format: wsim_api_{random}, nullable for OAuth-only clients

  // WebAuthn Related Origin for Quick Pay cross-domain passkey authentication
  // If set, this origin will be included in /.well-known/webauthn
  // Allows passkeys registered with WSIM to be used on the merchant's domain
  webauthnRelatedOrigin String? // e.g., "https://store.regalmoose.ca"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// =============================================================================
// PASSKEY CREDENTIALS (WebAuthn)
// =============================================================================

model PasskeyCredential {
  id     String     @id @default(uuid())
  userId String
  user   WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // WebAuthn credential data
  credentialId String @unique // Base64url encoded credential ID
  publicKey    String // Base64url encoded COSE public key
  counter      Int    @default(0) // Signature counter for replay protection
  transports   String[] // e.g., ["internal", "hybrid", "usb"]

  // Metadata
  deviceName String? // User-friendly name, e.g., "iPhone", "MacBook Pro"
  aaguid     String? // Authenticator attestation GUID

  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?

  @@index([userId])
}

// =============================================================================
// ADMIN USERS (for auth-server administration)
// =============================================================================
// NOTE: These tables are primarily used by auth-server, but must be included
// here to prevent prisma db push from dropping them. Both services share the
// same database, so schemas MUST be kept in sync.
// =============================================================================

enum AdminRole {
  ADMIN
  SUPER_ADMIN
}

model AdminUser {
  id             String         @id @default(uuid())
  email          String         @unique
  firstName      String
  lastName       String
  role           AdminRole      @default(ADMIN)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  passkeys       AdminPasskey[]
  invitesCreated AdminInvite[]  @relation("InviteCreator")
  inviteUsed     AdminInvite?   @relation("InviteUsed")

  @@map("admin_users")
}

model AdminPasskey {
  id                  String    @id @default(uuid())
  adminUserId         String
  adminUser           AdminUser @relation(fields: [adminUserId], references: [id], onDelete: Cascade)
  credentialId        String    @unique
  credentialPublicKey Bytes
  counter             BigInt
  deviceType          String
  backedUp            Boolean
  transports          String[]
  createdAt           DateTime  @default(now())
  lastUsedAt          DateTime?

  @@map("admin_passkeys")
}

// Admin invitations for new administrator signups
model AdminInvite {
  id          String            @id @default(uuid())
  code        String            @unique // The invite code shared with the invitee
  email       String?           // Optional: restrict invite to specific email
  role        AdminRole         @default(ADMIN)
  createdById String
  createdBy   AdminUser         @relation("InviteCreator", fields: [createdById], references: [id], onDelete: Cascade)
  usedById    String?           @unique
  usedBy      AdminUser?        @relation("InviteUsed", fields: [usedById], references: [id], onDelete: SetNull)
  usedAt      DateTime?
  expiresAt   DateTime
  revokedAt   DateTime?
  createdAt   DateTime          @default(now())

  @@map("admin_invites")
}

// =============================================================================
// MOBILE DEVICE REGISTRATION
// =============================================================================

model MobileDevice {
  id               String   @id @default(uuid())
  userId           String
  user             WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  deviceId         String   @unique  // Client-generated UUID
  platform         String   // "ios" or "android"
  deviceName       String

  // Push notification token (AD4: Extended for push notifications, AD6: Direct APNs/FCM)
  pushToken        String?  // APNs device token (hex) or FCM registration token
  pushTokenType    String?  // "apns" | "fcm" (expo deprecated per AD6)
  pushTokenActive  Boolean  @default(true) // False when token invalidated or user logged out
  pushTokenUpdatedAt DateTime? // Last time push token was updated

  // Device credential for authentication
  deviceCredential String   // Encrypted server-issued token
  credentialExpiry DateTime

  // Biometric info
  biometricEnabled Boolean  @default(false)
  biometricType    String?  // "face" or "fingerprint"
  biometricPublicKey String? // SPKI base64 for signature verification

  lastUsedAt       DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  refreshTokens    MobileRefreshToken[]

  @@index([userId])
  @@index([pushToken]) // Index for looking up devices by push token
  @@map("mobile_devices")
}

model MobileRefreshToken {
  id           String   @id @default(uuid())
  token        String   @unique
  userId       String
  user         WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceId     String
  device       MobileDevice @relation(fields: [deviceId], references: [deviceId], onDelete: Cascade)

  expiresAt    DateTime
  revokedAt    DateTime?
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([deviceId])
  @@map("mobile_refresh_tokens")
}

// =============================================================================
// MOBILE PAYMENT REQUESTS
// =============================================================================
// Payment requests created by merchants (SSIM) for mobile app approval (mwsim)
// Flow: SSIM creates request -> User opens in mwsim -> User approves -> SSIM completes

model MobilePaymentRequest {
  id              String    @id @default(cuid())

  // Merchant info (from OAuth client)
  merchantId      String    // OAuth client_id of the merchant
  merchantName    String    // Display name for the app
  merchantLogoUrl String?   // Logo URL for display in app

  // User (set when user opens request in app)
  userId          String?
  user            WalletUser? @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Order details
  orderId         String    // Merchant's order reference
  orderDescription String?  // Description shown to user
  orderDetails    Json?     // Enhanced purchase info (line items, tax, shipping, discounts)
  amount          Decimal   @db.Decimal(15, 2)
  currency        String    @default("CAD")
  returnUrl       String    // Where to redirect user after approval

  // Payment state
  status          String    @default("pending") // pending, approved, cancelled, expired, completed
  selectedCardId  String?   // Card user selected for payment

  // Tokens (set on approval)
  cardToken       String?   // Ephemeral card token from BSIM
  walletCardToken String?   // WSIM token for NSIM routing
  oneTimeToken    String?   @unique // One-time token for merchant to exchange for card tokens

  // Timestamps
  createdAt       DateTime  @default(now())
  expiresAt       DateTime  // 5 minutes from creation, extended 60s on approval
  approvedAt      DateTime?
  completedAt     DateTime?
  cancelledAt     DateTime?

  @@unique([merchantId, orderId, status], name: "unique_pending_request")
  @@index([merchantId, orderId])
  @@index([status])
  @@index([oneTimeToken])
  @@index([userId])
  @@map("mobile_payment_requests")
}

// =============================================================================
// PUSH NOTIFICATIONS
// =============================================================================
// Notification audit log for debugging and tracking delivery status

model NotificationLog {
  id               String    @id @default(uuid())
  userId           String    // Recipient user
  deviceId         String?   // Target device (if specific device)

  // Notification content
  notificationType String    // "transfer.received", "auth.challenge", etc.
  title            String
  body             String
  data             Json?     // Additional payload data (transferId, deepLink, etc.)

  // Delivery status
  status           String    @default("pending") // "pending", "sent", "delivered", "failed"
  errorMessage     String?   // Error details if failed

  // Source info (for webhook-triggered notifications)
  sourceType       String?   // "webhook", "system", "scheduled"
  sourceId         String?   // e.g., transferId, idempotencyKey for dedup

  // Timestamps
  createdAt        DateTime  @default(now())
  sentAt           DateTime?
  deliveredAt      DateTime?

  @@index([userId])
  @@index([sourceId]) // For idempotency checks
  @@index([status, createdAt]) // For monitoring/cleanup
  @@map("notification_logs")
}
