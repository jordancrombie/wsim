// WSIM - Wallet Simulator Database Schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// WALLET USER & PROFILE
// =============================================================================

model WalletUser {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String?  // Nullable - legacy users may not have passwords (passkey-only)
  firstName    String?
  lastName     String?
  walletId     String   @unique @default(uuid()) // Public wallet identifier
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Profile fields (Phase 1 User Profile feature)
  displayName     String?  // Editable display name (defaults to firstName + lastName)
  profileImageUrl String?  // CDN URL for profile image
  profileImageKey String?  // S3 key for deletion/replacement
  initialsColor   String?  // Background color for initials avatar fallback

  // Identity verification (Trusted User feature)
  isVerified        Boolean   @default(false)
  verifiedAt        DateTime?
  verificationLevel String?   // "none" | "basic" | "enhanced"

  // Relationships
  enrollments           BsimEnrollment[]
  walletCards           WalletCard[]
  paymentConsents       WalletPaymentConsent[]
  passkeyCredentials    PasskeyCredential[]
  mobileDevices         MobileDevice[]
  mobileRefreshTokens   MobileRefreshToken[]
  mobilePaymentRequests MobilePaymentRequest[]
  deviceKeys            DeviceKey[]
  verifications         UserVerification[]
  agents                Agent[]
  pairingCodes          PairingCode[]
  oauthAuthorizationCodes OAuthAuthorizationCode[]
}

// =============================================================================
// BSIM ENROLLMENT
// =============================================================================

model BsimEnrollment {
  id     String     @id @default(uuid())
  userId String
  user   WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // BSIM identification
  bsimId     String // e.g., "td-bank", "rbc-bank"
  bsimIssuer String // OIDC issuer URL
  fiUserRef  String // User's ID at this bsim (sub claim)

  // Wallet credential (wcred_xxx token from BSIM for card operations)
  walletCredential String // Encrypted credential

  // OAuth access token (JWT for Open Banking API calls like /accounts)
  accessToken String? // Encrypted JWT - nullable for backwards compatibility

  // Token expiry (applies to accessToken, wallet credential may have longer expiry)
  credentialExpiry DateTime?

  // Refresh token for token renewal
  refreshToken String? // Encrypted

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Cards from this enrollment
  cards WalletCard[]

  @@unique([userId, bsimId])
  @@index([userId])
}

// =============================================================================
// WALLET CARDS
// =============================================================================

model WalletCard {
  id           String         @id @default(uuid())
  userId       String
  user         WalletUser     @relation(fields: [userId], references: [id], onDelete: Cascade)
  enrollmentId String
  enrollment   BsimEnrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)

  // Card display info (masked - no full card numbers stored)
  cardType       String // VISA, MC, AMEX, VISA_DEBIT, MC_DEBIT
  lastFour       String // Last 4 digits
  cardholderName String
  expiryMonth    Int
  expiryYear     Int

  // Card reference at bsim (NOT the actual card number)
  bsimCardRef String // Reference ID at bsim

  // Wallet card token (wsim-issued, for nsim routing)
  // Format: wsim_{bsimId}_{uniqueId}
  walletCardToken String @unique

  // Status
  isDefault Boolean @default(false)
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([enrollmentId, bsimCardRef])
  @@index([userId])
  @@index([walletCardToken])
}

// =============================================================================
// PAYMENT CONSENTS (for SSIM payments)
// =============================================================================

model WalletPaymentConsent {
  id     String     @id @default(uuid())
  userId String
  user   WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Merchant info
  merchantId   String
  merchantName String

  // Selected card
  walletCardId String

  // Consent details
  scope     String // e.g., "payment:single" or "payment:recurring"
  maxAmount Decimal? @db.Decimal(15, 2)

  // Token issued to merchant (returned in OIDC token claims)
  consentToken String @unique

  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([consentToken])
}

// =============================================================================
// PAYMENT CONTEXT (temporary storage during OIDC flow)
// =============================================================================

model PaymentContext {
  id String @id @default(uuid())

  // Link to OIDC grant
  grantId String @unique

  // Selected card info
  walletCardId    String
  walletCardToken String // WSIM token for NSIM routing

  // Card token from BSIM (for payment processing)
  bsimCardToken String?

  // Payment details from SSIM
  merchantId   String?
  merchantName String?
  amount       Decimal? @db.Decimal(15, 2)
  currency     String?

  createdAt DateTime @default(now())
  expiresAt DateTime // Short-lived, 10 minutes

  @@index([grantId])
}

// =============================================================================
// OIDC PROVIDER STORAGE (for auth-server)
// =============================================================================

model OidcPayload {
  id         String    @id
  type       String // e.g., "Session", "AccessToken", "AuthorizationCode", etc.
  payload    String    @db.Text
  grantId    String?
  userCode   String?
  uid        String?
  expiresAt  DateTime?
  consumedAt DateTime?

  @@index([grantId])
  @@index([userCode])
  @@index([uid])
}

// =============================================================================
// OAUTH CLIENTS (SSIMs registered to use WSIM)
// =============================================================================

model OAuthClient {
  id                     String   @id @default(uuid())
  clientId               String   @unique
  clientSecret           String // Hashed
  clientName             String
  redirectUris           String[]
  postLogoutRedirectUris String[]
  grantTypes             String[] // e.g., ["authorization_code", "refresh_token"]
  scope                  String // Space-separated scopes
  logoUri                String?
  trusted                Boolean  @default(false) // Skip consent for trusted clients

  // Merchant API key for direct API access (Phase 3)
  apiKey String? @unique // Format: wsim_api_{random}, nullable for OAuth-only clients

  // WebAuthn Related Origin for Quick Pay cross-domain passkey authentication
  // If set, this origin will be included in /.well-known/webauthn
  // Allows passkeys registered with WSIM to be used on the merchant's domain
  webauthnRelatedOrigin String? // e.g., "https://store.regalmoose.ca"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// =============================================================================
// PASSKEY CREDENTIALS (WebAuthn)
// =============================================================================

model PasskeyCredential {
  id     String     @id @default(uuid())
  userId String
  user   WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // WebAuthn credential data
  credentialId String @unique // Base64url encoded credential ID
  publicKey    String // Base64url encoded COSE public key
  counter      Int    @default(0) // Signature counter for replay protection
  transports   String[] // e.g., ["internal", "hybrid", "usb"]

  // Metadata
  deviceName String? // User-friendly name, e.g., "iPhone", "MacBook Pro"
  aaguid     String? // Authenticator attestation GUID

  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?

  @@index([userId])
}

// =============================================================================
// ADMIN USERS (for auth-server administration)
// =============================================================================
// NOTE: These tables are primarily used by auth-server, but must be included
// here to prevent prisma db push from dropping them. Both services share the
// same database, so schemas MUST be kept in sync.
// =============================================================================

enum AdminRole {
  ADMIN
  SUPER_ADMIN
}

model AdminUser {
  id             String         @id @default(uuid())
  email          String         @unique
  firstName      String
  lastName       String
  role           AdminRole      @default(ADMIN)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  passkeys       AdminPasskey[]
  invitesCreated AdminInvite[]  @relation("InviteCreator")
  inviteUsed     AdminInvite?   @relation("InviteUsed")

  @@map("admin_users")
}

model AdminPasskey {
  id                  String    @id @default(uuid())
  adminUserId         String
  adminUser           AdminUser @relation(fields: [adminUserId], references: [id], onDelete: Cascade)
  credentialId        String    @unique
  credentialPublicKey Bytes
  counter             BigInt
  deviceType          String
  backedUp            Boolean
  transports          String[]
  createdAt           DateTime  @default(now())
  lastUsedAt          DateTime?

  @@map("admin_passkeys")
}

// Admin invitations for new administrator signups
model AdminInvite {
  id          String            @id @default(uuid())
  code        String            @unique // The invite code shared with the invitee
  email       String?           // Optional: restrict invite to specific email
  role        AdminRole         @default(ADMIN)
  createdById String
  createdBy   AdminUser         @relation("InviteCreator", fields: [createdById], references: [id], onDelete: Cascade)
  usedById    String?           @unique
  usedBy      AdminUser?        @relation("InviteUsed", fields: [usedById], references: [id], onDelete: SetNull)
  usedAt      DateTime?
  expiresAt   DateTime
  revokedAt   DateTime?
  createdAt   DateTime          @default(now())

  @@map("admin_invites")
}

// =============================================================================
// MOBILE DEVICE REGISTRATION
// =============================================================================

model MobileDevice {
  id               String   @id @default(uuid())
  userId           String
  user             WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  deviceId         String   @unique  // Client-generated UUID
  platform         String   // "ios" or "android"
  deviceName       String

  // Push notification token (AD4: Extended for push notifications, AD6: Direct APNs/FCM)
  pushToken        String?  // APNs device token (hex) or FCM registration token
  pushTokenType    String?  // "apns" | "fcm" (expo deprecated per AD6)
  pushTokenActive  Boolean  @default(true) // False when token invalidated or user logged out
  pushTokenUpdatedAt DateTime? // Last time push token was updated

  // Device credential for authentication
  deviceCredential String   // Encrypted server-issued token
  credentialExpiry DateTime

  // Biometric info
  biometricEnabled Boolean  @default(false)
  biometricType    String?  // "face" or "fingerprint"
  biometricPublicKey String? // SPKI base64 for signature verification

  lastUsedAt       DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  refreshTokens    MobileRefreshToken[]

  @@index([userId])
  @@index([pushToken]) // Index for looking up devices by push token
  @@map("mobile_devices")
}

model MobileRefreshToken {
  id           String   @id @default(uuid())
  token        String   @unique
  userId       String
  user         WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceId     String
  device       MobileDevice @relation(fields: [deviceId], references: [deviceId], onDelete: Cascade)

  expiresAt    DateTime
  revokedAt    DateTime?
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([deviceId])
  @@map("mobile_refresh_tokens")
}

// =============================================================================
// MOBILE PAYMENT REQUESTS
// =============================================================================
// Payment requests created by merchants (SSIM) for mobile app approval (mwsim)
// Flow: SSIM creates request -> User opens in mwsim -> User approves -> SSIM completes

model MobilePaymentRequest {
  id              String    @id @default(cuid())

  // Merchant info (from OAuth client)
  merchantId      String    // OAuth client_id of the merchant
  merchantName    String    // Display name for the app
  merchantLogoUrl String?   // Logo URL for display in app

  // User (set when user opens request in app)
  userId          String?
  user            WalletUser? @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Order details
  orderId         String    // Merchant's order reference
  orderDescription String?  // Description shown to user
  orderDetails    Json?     // Enhanced purchase info (line items, tax, shipping, discounts)
  amount          Decimal   @db.Decimal(15, 2)
  currency        String    @default("CAD")
  returnUrl       String    // Where to redirect user after approval

  // Payment state
  status          String    @default("pending") // pending, approved, cancelled, expired, completed
  selectedCardId  String?   // Card user selected for payment

  // Tokens (set on approval)
  cardToken       String?   // Ephemeral card token from BSIM
  walletCardToken String?   // WSIM token for NSIM routing
  oneTimeToken    String?   @unique // One-time token for merchant to exchange for card tokens

  // Timestamps
  createdAt       DateTime  @default(now())
  expiresAt       DateTime  // 5 minutes from creation, extended 60s on approval
  approvedAt      DateTime?
  completedAt     DateTime?
  cancelledAt     DateTime?

  @@unique([merchantId, orderId, status], name: "unique_pending_request")
  @@index([merchantId, orderId])
  @@index([status])
  @@index([oneTimeToken])
  @@index([userId])
  @@map("mobile_payment_requests")
}

// =============================================================================
// PUSH NOTIFICATIONS
// =============================================================================
// Notification audit log for debugging and tracking delivery status

model NotificationLog {
  id               String    @id @default(uuid())
  userId           String    // Recipient user
  deviceId         String?   // Target device (if specific device)

  // Notification content
  notificationType String    // "transfer.received", "auth.challenge", etc.
  title            String
  body             String
  data             Json?     // Additional payload data (transferId, deepLink, etc.)

  // Delivery status
  status           String    @default("pending") // "pending", "sent", "delivered", "failed"
  errorMessage     String?   // Error details if failed

  // Source info (for webhook-triggered notifications)
  sourceType       String?   // "webhook", "system", "scheduled"
  sourceId         String?   // e.g., transferId, idempotencyKey for dedup

  // Timestamps
  createdAt        DateTime  @default(now())
  sentAt           DateTime?
  deliveredAt      DateTime?

  @@index([userId])
  @@index([sourceId]) // For idempotency checks
  @@index([status, createdAt]) // For monitoring/cleanup
  @@map("notification_logs")
}

// =============================================================================
// IDENTITY VERIFICATION (Trusted User Feature)
// =============================================================================

model DeviceKey {
  id           String      @id @default(cuid())
  userId       String
  user         WalletUser  @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceId     String      @unique
  publicKey    String      // Base64-encoded SPKI public key
  keyType      String      // "ECDSA-P256" or "RSA-2048"
  registeredAt DateTime    @default(now())
  lastUsedAt   DateTime?

  @@index([userId])
  @@map("device_keys")
}

model UserVerification {
  id                String      @id @default(cuid())
  userId            String
  user              WalletUser  @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceId          String
  verificationLevel String      // "basic" | "enhanced"
  documentType      String      // "PASSPORT"
  issuingCountry    String      // 3-letter ISO code
  nameMatchScore    Float
  faceMatchScore    Float?
  livenessPassed    Boolean?
  verifiedAt        DateTime
  expiresAt         DateTime
  createdAt         DateTime    @default(now())

  @@index([userId])
  @@map("user_verifications")
}

// =============================================================================
// AGENT COMMERCE (SACP - SimToolBox Agent Commerce Protocol)
// =============================================================================
// AI agents that can make purchases on behalf of users with spending controls

model Agent {
  id                  String   @id @default(uuid())
  userId              String
  user                WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Client credentials (OAuth 2.0 client credentials flow)
  clientId            String   @unique  // Format: "agent_{nanoid(12)}"
  clientSecretHash    String             // bcrypt hashed secret

  // Agent metadata
  name                String             // User-friendly name
  description         String?

  // Permissions (what the agent can do)
  permissions         String[]           // ["browse", "cart", "purchase", "history"]

  // Spending limits (in user's currency)
  perTransactionLimit Decimal  @db.Decimal(15, 2)  // Max per single transaction
  dailyLimit          Decimal  @db.Decimal(15, 2)  // Max per day (resets at midnight EST)
  monthlyLimit        Decimal  @db.Decimal(15, 2)  // Max per calendar month
  limitCurrency       String   @default("CAD")

  // Status
  status              String   @default("active") // "active", "suspended", "revoked"

  // Timestamps
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  lastUsedAt          DateTime?
  secretRotatedAt     DateTime?  // Track when secret was last rotated

  // Relationships
  accessTokens        AgentAccessToken[]
  transactions        AgentTransaction[]
  stepUpRequests      StepUpRequest[]
  accessRequest       AccessRequest?     @relation("AccessRequestAgent")

  @@index([userId])
  @@index([clientId])
  @@map("agents")
}

model AgentAccessToken {
  id          String    @id @default(uuid())
  agentId     String
  agent       Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)

  // Token identifier (SHA-256 hash for revocation lookup)
  tokenHash   String    @unique

  // Token metadata
  scope       String?              // Space-separated scopes if restricted
  issuedAt    DateTime  @default(now())
  expiresAt   DateTime
  revokedAt   DateTime?

  @@index([agentId])
  @@index([tokenHash])
  @@index([expiresAt])
  @@map("agent_access_tokens")
}

model AgentTransaction {
  id                    String    @id @default(uuid())
  agentId               String
  agent                 Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)

  // Transaction details
  amount                Decimal   @db.Decimal(15, 2)
  currency              String    @default("CAD")
  merchantId            String
  merchantName          String?
  sessionId             String?   // Merchant checkout session ID

  // Payment method used
  paymentMethodId       String?   // WalletCard ID
  paymentMethodLastFour String?   // Last 4 digits for display

  // Status
  status                String    @default("pending") // "pending", "completed", "failed", "refunded"
  approvalType          String?   // "auto" or "step_up"

  // For spending limit calculation (period boundaries)
  dailyPeriodStart      DateTime  // Start of day in EST
  monthlyPeriodStart    DateTime  // Start of month

  // Timestamps
  createdAt             DateTime  @default(now())
  completedAt           DateTime?

  // Link to step-up if required
  stepUpId              String?   @unique
  stepUp                StepUpRequest? @relation(fields: [stepUpId], references: [id])

  @@index([agentId])
  @@index([agentId, dailyPeriodStart])
  @@index([agentId, monthlyPeriodStart])
  @@index([status])
  @@map("agent_transactions")
}

model StepUpRequest {
  id                        String    @id @default(uuid())
  agentId                   String
  agent                     Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)

  // Payment request details
  amount                    Decimal   @db.Decimal(15, 2)
  currency                  String
  merchantId                String
  merchantName              String?
  sessionId                 String?   // Merchant checkout session ID

  // Cart items for display (JSON array)
  items                     Json?     // Array of { name, quantity, price }

  // Reason for step-up
  reason                    String    // Human-readable reason
  triggerType               String    // "per_transaction", "daily_limit", "monthly_limit"

  // Status
  status                    String    @default("pending") // "pending", "approved", "rejected", "expired"

  // Payment method (can be changed during approval)
  requestedPaymentMethodId  String?   // Originally requested
  approvedPaymentMethodId   String?   // What user approved with

  // Timestamps
  createdAt                 DateTime  @default(now())
  expiresAt                 DateTime  // 15 minutes from creation
  resolvedAt                DateTime?

  // Result
  rejectionReason           String?

  // Back-reference to transaction (created after approval)
  transaction               AgentTransaction?

  @@index([agentId])
  @@index([status, expiresAt])
  @@map("step_up_requests")
}

model MerchantWebhook {
  id              String    @id @default(uuid())

  // Merchant identification (matches introspection client)
  merchantId      String    @unique  // e.g., "ssim_introspect"

  // Webhook configuration
  webhookUrl      String              // HTTPS endpoint to receive events
  webhookSecret   String              // HMAC-SHA256 signing secret

  // Events to receive (e.g., ["token.revoked", "agent.deactivated"])
  events          String[]

  // Status
  enabled         Boolean   @default(true)

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Delivery tracking
  deliveryLogs    WebhookDeliveryLog[]

  @@map("merchant_webhooks")
}

model WebhookDeliveryLog {
  id              String    @id @default(uuid())
  webhookId       String
  webhook         MerchantWebhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  // Event details
  eventType       String              // e.g., "token.revoked"
  payload         Json                // Full payload sent

  // Delivery result
  statusCode      Int?                // HTTP response code (null if failed to connect)
  responseBody    String?             // Response body (truncated)
  error           String?             // Error message if delivery failed

  // Timing
  attemptedAt     DateTime  @default(now())
  durationMs      Int?                // How long the request took

  @@index([webhookId])
  @@index([eventType])
  @@index([attemptedAt])
  @@map("webhook_delivery_logs")
}

// =============================================================================
// OAUTH AUTHORIZATION CODES (Browser-based Authorization Code Flow)
// =============================================================================
// Stores pending and issued authorization codes for OAuth Authorization Code flow
// with PKCE support. Used by ChatGPT Connectors and browser-based AI platforms.

model OAuthAuthorizationCode {
  id              String    @id @default(uuid())

  // The authorization code (issued after user approval)
  code            String?   @unique  // null until user approves

  // Client identification
  clientId        String              // Pre-registered OAuth client (e.g., "chatgpt")
  redirectUri     String              // Where to redirect after auth

  // PKCE (RFC 7636)
  codeChallenge   String              // SHA256 hash of code_verifier
  codeChallengeMethod String @default("S256")

  // State for CSRF protection
  state           String?

  // Scope requested
  scope           String?             // Space-separated scopes

  // User identification (set after user identifies themselves)
  userId          String?
  user            WalletUser? @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Status
  status          String    @default("pending_identification")
  // "pending_identification" - waiting for user to enter email
  // "pending_approval" - push sent, waiting for user approval
  // "approved" - user approved, code issued
  // "rejected" - user rejected
  // "used" - code exchanged for tokens
  // "expired" - expired before completion

  // Timestamps
  createdAt       DateTime  @default(now())
  expiresAt       DateTime            // 10 minutes from creation
  approvedAt      DateTime?
  usedAt          DateTime?

  @@index([code])
  @@index([clientId])
  @@index([userId])
  @@index([status, expiresAt])
  @@map("oauth_authorization_codes")
}

// =============================================================================
// AGENT ACCESS REQUESTS (Agent-Initiated Credential Flow)
// =============================================================================

model PairingCode {
  id        String   @id @default(uuid())
  userId    String
  user      WalletUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // The actual pairing code (format: WSIM-XXXXXX-XXXXXX)
  code      String   @unique

  // Status tracking
  status    String   @default("active") // "active", "used", "expired"
  usedAt    DateTime?

  // Timestamps
  createdAt DateTime @default(now())
  expiresAt DateTime // 24 hours from creation

  // Back-reference to access request that used this code
  accessRequest AccessRequest?

  @@index([userId])
  @@index([code])
  @@index([status, expiresAt])
  @@map("pairing_codes")
}

model AccessRequest {
  id              String   @id @default(uuid())

  // Pairing code used to create this request
  pairingCodeId   String   @unique
  pairingCode     PairingCode @relation(fields: [pairingCodeId], references: [id], onDelete: Cascade)

  // Agent details (provided by the requesting agent)
  agentName       String
  agentDescription String?

  // Requested permissions and limits
  requestedPermissions String[]           // ["browse", "cart", "purchase"]
  requestedPerTransaction Decimal @db.Decimal(15, 2)
  requestedDailyLimit     Decimal @db.Decimal(15, 2)
  requestedMonthlyLimit   Decimal @db.Decimal(15, 2)
  requestedCurrency       String  @default("CAD")

  // Delivery method
  deliveryMethod  String   @default("push") // "push", "qr"

  // Status
  status          String   @default("pending") // "pending", "approved", "rejected", "expired"

  // Granted permissions and limits (may differ from requested - user can decrease)
  grantedPermissions      String[] @default([])
  grantedPerTransaction   Decimal? @db.Decimal(15, 2)
  grantedDailyLimit       Decimal? @db.Decimal(15, 2)
  grantedMonthlyLimit     Decimal? @db.Decimal(15, 2)

  // Result
  rejectionReason String?

  // Back-reference to created agent (populated after approval)
  agentId         String?  @unique
  agent           Agent?   @relation("AccessRequestAgent", fields: [agentId], references: [id])

  // Timestamps
  createdAt       DateTime @default(now())
  expiresAt       DateTime // 24 hours from creation
  resolvedAt      DateTime?

  @@index([status, expiresAt])
  @@map("access_requests")
}
